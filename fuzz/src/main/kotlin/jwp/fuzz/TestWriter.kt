package jwp.fuzz

import com.squareup.javapoet.*
import java.util.*
import javax.lang.model.element.Modifier

abstract class TestWriter(val conf: Config) {

    protected val typeBld = TypeSpec.classBuilder(conf.simpleClassName).addModifiers(Modifier.PUBLIC)

    // This can be called by multiple threads
    abstract fun append(result: ExecutionResult)

    open fun flush(to: Appendable) = JavaFile.builder(conf.packageName, typeBld.build()).apply {
        addFileComment("File generated by JWP fuzzer")
    }.build().writeTo(to)

    protected open fun invokeAndStore(result: ExecutionResult) = CodeBlock.builder().apply {
        // Make the call and store result in local var if not void
        val call = CodeBlock.builder()
        if (result.invokeResult is ExecutionResult.InvokeResult.Ok && result.method.returnType != Void.TYPE)
            call.add("\$T result = ", result.method.genericReturnType)

        // Invoke the method
        // TODO: instance methods?
        require(java.lang.reflect.Modifier.isStatic(result.method.modifiers))
        call.add("\$T.${result.method.name}(", result.method.declaringClass)
        result.params.indices.forEach { appendItem(this, call, result.rawParam(it)) }
        call.add(");\n")
        add(call.build())
    }

    protected open fun appendItem(preCode: CodeBlock.Builder, code: CodeBlock.Builder, item: Any?) {
        when (item) {
            null -> code.add("null")
            is List<*> -> code.add("\$T.asList(", Arrays::class.java).also {
                item.forEachIndexed { index, subItem ->
                    if (index > 0) code.add(", ")
                    appendItem(preCode, code, subItem)
                }
            }.add(")")
            is String -> code.add("\$L", doubleQuotedString(item))
            else -> error("Items of type ${item.javaClass} not yet supported")
        }
    }

    class JUnit4(conf: Config) : TestWriter(conf) {

        @Synchronized
        override fun append(result: ExecutionResult) {
            MethodSpec.methodBuilder(conf.namer.name(result)).apply {
                addModifiers(Modifier.PUBLIC)
                // Create @Test annotation, add expected exception if there
                val testAnn = AnnotationSpec.builder(ClassName.get("org.junit", "Test"))
                if (result.invokeResult is ExecutionResult.InvokeResult.Failure) {
                    testAnn.addMember("expected", "\$T.class", result.invokeResult.ex.javaClass)
                    addComment("Got exception \$L: \$L", result.invokeResult.ex.javaClass.simpleName,
                        doubleQuotedString(result.invokeResult.ex.message))
                }
                addAnnotation(testAnn.build())
                // Add the code
                addCode(invokeAndStore(result).apply {
                    // If there is a result type, do an assertion
                    if (result.invokeResult is ExecutionResult.InvokeResult.Ok &&
                            result.method.returnType != Void.TYPE) {
                        val assertMethodName =
                            if (result.method.returnType.isArray) "assertArrayEquals"
                            else "assertEquals"
                        val assertCall = CodeBlock.builder().add(
                            "\$T.$assertMethodName(", ClassName.get("org.junit", "Assert"))
                        appendItem(this, assertCall, result.invokeResult.value)
                        add(assertCall.add(", result);\n").build())
                    }
                }.build())
            }.build().let(typeBld::addMethod)
        }
    }

    companion object {
        fun doubleQuotedString(string: String?) = CodeBlock.of("\$S", string).let {
            // https://github.com/square/javapoet/issues/604 :-(
            var str = it.toString()
            while (true) {
                val endQuoteIndex = str.indexOf("\"\n")
                if (endQuoteIndex == -1) break
                str = str.substring(0, endQuoteIndex) + str.substring(str.indexOf('+', endQuoteIndex) + 3)
            }
            str
        }
    }

    interface Namer {
        // Does not have to be thread safe
        fun name(result: ExecutionResult): String

        class SuccessOrFailCounted(val prefix: String = "test") : Namer {
            var successCount = 0
            var failureCount = 0
            override fun name(result: ExecutionResult) = when (result.invokeResult) {
                is ExecutionResult.InvokeResult.Ok -> prefix + "Success" + ++successCount
                is ExecutionResult.InvokeResult.Failure -> prefix + "Fail" + ++failureCount
            }
        }
    }

    data class Config(
        val className: String,
        val namer: Namer = Namer.SuccessOrFailCounted()
    ) {
        val simpleClassName get() = className.substringAfterLast('.')
        val packageName get() = className.substringBeforeLast('.', "")
    }
}